---
layout: post
title: One environment to rule them all
category: draft
---
Programs rely on the fact, that the environment of their process cannot be changed outside of it. Because of that, if that happens, this might lead to reading invalid data by the program or, what's worse, silently altering its behaviour. Generally the OS is responsible for enforcing that, however it might become a problem if another program, that's designed to be executed in a separate process, is executed inside another process. Since environment variables are [used heavily](https://github.com/rust-lang/cargo/blob/master/src/doc/environment-variables.md) by the Cargo and Rust compiler itself, RLS has to be very cautious about providing the same environment change guarantees as the OS does, for the duration of the underlying tool's execution.

I was recently trying to switch the way the compiler is invoked while [working on supporting Cargo workspaces in RLS]({% post_url 2017-07-24-supporting-workspaces-in-rls %}). During that time, an [implementation](https://github.com/rust-lang-nursery/rls/commit/79d659e5699fbf7db5b4819e9a442fb3f550472a#diff-9997203f2de5b62d7810f98eebd0cb72R414) of a  **mut**ually **ex**clusive access to the environment, using a simple `Mutex<()>` and an `Environment` RAII guard, which held the `Mutex` lock guard, has landed. After that, I encountered a strange regression for the workspace support test - the environment was effectively locked (somewhat) recursively, leading to a deadlock.

The initial implementation of the scope locking the environment with a `Mutex` used only a single lock. Originally, during the Cargo build routine, `rustc` compiler instances were ran as separate processes, each one having its own environment appropriately set by Cargo. However, executing the linked compiler lead to an attempt to lock the environment for the duration of the compilation, while it was still locked previously at the outer scope for the entire duration of Cargo execution. Oops.

What's needed was to provide a consistent and scoped environment at an outer scope, the Cargo execution, but also at the inner one, the compiler scope. Locking two separate `Mutex`es would not work, as we also support straight `rustc` build routine, where we don't invoke Cargo. Running both Cargo and `rustc` build routines in parallel could lead to an inconsistent environment - it's easy to imagine a scenario where there's a data race resulting in an inconsistent environment for one of the two.

The solution for the problem seemed like an easy one - all builds should first acquire a single, shared lock and whilst holding it, possibly acquire an inner one for the duration not longer than the first one is held for. It'd be great to encode that information using RAII guards with specified lifetimes of the lock, all while guaranteeing the order of locking, however there was one problem with this approach.

To intercept planned `rustc` calls, Cargo exposes an `Executor` trait, which effectively provides a callback (`exec()`) with all the arguments and environment `rustc` would be called, so the compiler execution can be freely customized. What's unfortunate is that the API expects an `Arc<Executor>`. This means, that there are no guarantees that the passed pointer will not be further copied out of scope, so we can't really limit the lifetime of the inner lock here (since it has to live shorter than the outer lock).

At the moment, current implementation unfortunately does not strictly enforce lock order. Ideally, the access to the second, inner lock should only be given if and only if the outer lock is held. The outer `lock` [function](https://github.com/rust-lang-nursery/rls/blob/master/src/build/environment.rs#L108) returns a `(MutexGuard<'a, ()>, InnerLock)`, where `InnerLock` is a [unit struct](https://github.com/rust-lang-nursery/rls/blob/master/src/build/environment.rs#L119) that has access to the static inner lock and should not live longer than the returned outer lock guard. While technically it can be copied outside the scope of the initial lock guard, it seems acceptable for the time being, as it's required to further the work needed to support the workspaces in the RLS.

