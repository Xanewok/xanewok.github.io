---
layout: post
title: One environment to rule them all
category: draft
---
Programs rely on the fact that the environment of their process cannot be changed outside of it. Because of that, if that happens, this might lead to reading invalid data by the program or, what's worse, silently altering its behaviour. Generally the OS is responsible for enforcing that, however it might become a problem if another program, that's designed to be executed in a separate process, is executed inside another process. Since environment variables are [used heavily](https://github.com/rust-lang/cargo/blob/master/src/doc/environment-variables.md) by the Cargo and Rust compiler itself, RLS has to be very cautious about providing the same environment change guarantees as the OS does, for the duration of the underlying tool's execution. It's easy to imagine that running `cargo` and `rustc` in parallel, in-process, could lead a data race - they share environment state, but they can read it and alter it in an interleaved fashion, if not coordinated.

I was recently trying to switch the way the compiler is invoked while [working on supporting Cargo workspaces in RLS]({% post_url 2017-07-24-supporting-workspaces-in-rls %}). During that time, an [implementation](https://github.com/rust-lang-nursery/rls/commit/79d659e5699fbf7db5b4819e9a442fb3f550472a#diff-9997203f2de5b62d7810f98eebd0cb72R414) of a mutually exclusive access to the environment, using a simple `Mutex<()>` and an `Environment` RAII guard, which held the `Mutex` lock guard, has landed. After that, I encountered a strange regression for the workspace support test - the environment was effectively locked (somewhat) recursively, leading to a deadlock.

The initial implementation of the scope locking the environment with a `Mutex` used only a single lock. Originally, during the Cargo build routine, `rustc` compiler instances were ran as separate processes, each one having its own environment appropriately set by Cargo. However, executing the linked compiler lead to an attempt to lock the environment for the duration of the compilation, while it was still locked previously at the outer scope for the entire duration of Cargo execution. Oops.

What's needed was to provide a consistent and scoped environment at an outer scope, the Cargo execution, but also at the inner one, the compiler scope. Locking two separate, unrelated `Mutex`es for each scope would not work. Because `rustc` build routine can be also executed both separately and as a part of Cargo build routine, we need to provide a single, shared outer lock for both situations. If we don't, Cargo could acquire the outer lock and access the environment, while another `rustc` build routine would just acquire inner lock, still leading to sharing the environment for both. 

The solution for the problem seemed like an easy one - all builds should first acquire a single, shared lock and whilst holding it, possibly acquire an inner one for the duration not longer than the first one is held for. It'd be great to encode that information using RAII guards with specified lifetimes of the lock, all while guaranteeing the order of locking, however there was one problem with this approach.

To intercept planned `rustc` calls, Cargo exposes an `Executor` trait, which effectively provides a callback (`exec()`) with all the arguments and environment `rustc` would be called, so the compiler execution can be freely customized. What's unfortunate is that the API expects an `Arc<Executor>`. This means, that there are no guarantees that the passed pointer will not be further copied out of scope, so we can't really limit the lifetime of the inner lock here (since it has to live shorter than the outer lock).

At the moment, current implementation unfortunately does not strictly enforce lock order. Ideally, the access to the second, inner lock should only be given if and only if the outer lock is held. The outer `lock` [function](https://github.com/rust-lang-nursery/rls/blob/master/src/build/environment.rs#L108) returns a `(MutexGuard<'a, ()>, InnerLock)`, where `InnerLock` is a [unit struct](https://github.com/rust-lang-nursery/rls/blob/master/src/build/environment.rs#L119) that has access to the static inner lock and should not live longer than the returned outer lock guard. While technically it can be copied outside the scope of the initial lock guard, it seems acceptable for the time being, as it's required to further the work needed to support the workspaces in the RLS.

